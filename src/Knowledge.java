public class Knowledge {
}

/*

自增运算符：++
自减运算符：--

基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1。
使用格式：写在变量名称之前，或者写在变量名称之后。例如：++num，也可以num++。
使用方法：
	1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。
	2. 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。
使用区别：
	1. 在单独使用的时候，前++和后++没有任何区别。也就是： ++num：和num++；是完全一样的。
	2. 在混合的时候，有重大区别
		A. 如果是前++，那么变量立刻马上+1，然后拿着结果进行使用。  先加后用
		B. 如果是后++，那么首先使用变量本来的值，然后再让变量+1。  先用后加

注意事项：
	只有变量才能使用自增，自减运算符。常量不可发生改变，所以不能用。


赋值运算符分为：

基本赋值运算符：就是一个等号“=”，代表将右侧的数据交给左侧的变量。
	int a = 30

复合赋值运算符：
	+=		a += 3		相当于		a = a + 3
	-=		b -= 4		相当于		b = b + 4
	*=		c *= 5		相当于		c = c * 5
	/=		d /= 6		相当于		d = d / 6
	%=		e %= 7		相当于		e = e % 7

注意事项：
	1. 只有变量才能使用赋值运算符，常量不能进行赋值。
	2. 复合赋值运算符其中隐含了一个强制类型转换。




比较运算符：
大于：				>
小于：              <
大于等于：			>=
小于等于：			<=
相等：				==
不相等：			!=

注意事项：
1. 比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false。
2. 如果进行多次判断，不能连着写。
数学当中的写法，例如：1 < x < 3  程序中不允许这种写法。





与（并且）	&& 全都是true，才是true；否则就是false。
或（或者）	|| 至少一个是true，就是true；全都是false，才是false。
非（取反）  ！ 本来是true，变成false；本来是false，变成true。

与“&&”，或“||”，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。

注意事项：
1. 逻辑运算符只能用于Boolean值。
2. 与，或需要左右各自有一个Boolean值，但是取反只要唯一的一个Boolean值即可。
3. 与，或两种运算符，如果有多个条件，可以连续写。
两个条件：条件A && 条件B
多个条件：条件A && 条件B && 条件c

TIPS
对于1 < x < 3的情况，应该拆成两个部分，然后使用与运算符连接起来：





switch语句使用注意事项：

1. 多个case后面的数值不可以重复。

2. switch后面小括号当中只能是下列数据类型：
基本数据类型： byte/short/char/int
应用数据类型： String字符串，enum枚举

3. switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。
“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”



while循环有一个标准格式，还有一个拓展格式。

标准格式；
while（条件判断）




三种循环的区别：
1. 如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。
2. for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。




break关键字的用法有常见的两种：
1. 可以用在switch语句当中，一旦执行，整个switch语句立刻结束。
2. 还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。

关于循环的选择，有一个小建议；
凡是次数确定的场景多用for循环；否则多用while循环。


另一种循环控制语句是continue关键字。
一旦执行，立刻跳过当前循环剩余内容，马上开始下一次循环。





方法定义格式：
public static void 方法名称（）{
		方法体
}


调用格式：
方法名称（）；

注意事项：
1. 方法定义的先后顺序无所谓。
2. 方法定义必须是挨着的，不能在一个方法的内部定义另外一个方法。
3. 方法定义之后，自己不会执行的；如果希望执行，一定要进行方法的调用。


方法其实就是若干语句的功能集合。

参数（原料）：就是进入方法的数据。
返回值（产出物）：就是从方法中出来的数据。

定义方法的完整格式：
修饰符 返回值类型 方法名称（参数类型，参数名称，。。。）{
方法体
return 返回值；
}

修饰符：现阶段的固定写法，public static
返回值类型：也就是方法最终产生的数据结果是什么类型
方法名称： 方法的名字，规则和变量一样，小驼峰
参数类型： 进入方法的数据是什么类型
参数名称： 进入方法的数据对应的变量名称
ps： 参数如果有多个，使用逗号进行分隔
方法体： 方法需要做的事情，若干行代码
return： 两个作用，第一停止当前方法，第二将后面的返回值还给调用处
返回值： 也就是方法执行后最终产生的数据结果

注意： return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应

方法的三种调用：
1. 单独调用： 方法名称（参数）
2. 打印调用： System.out.println(方法名称（参数）)；
3. 赋值调用： 数据类型 变量名称 = 方法名称（参数）

注意： 此前学习的方法，返回值类型固定写为void，这种方法只能够单独调用，不能进行打印调用或者赋值调用





方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。
好处： 只需要记住唯一一个方法名称，就可以实现类似的多个功能

方法重载与下列因素相关：
1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同

方法重载与下列因素无关：
1. 与参数的名称无关
2. 与方法的返回值类型无关





数组的概念： 是一种容器，可以同时存放多个数据值。

数组的特点：
1. 数组是一种引用数据类型
2. 数组当中的多个数据，类型必须统一
3. 数组的长度在程序运行期间不可改变




数组的初始化： 在内存当中创建一个数组，并且向其中赋予一些默认值。

两种常见的初始化方法：
1. 动态初始化 （指定长度）
2. 静态初始化 （指定内容）

动态初始化数组的格式：
数据类型【】 数组名称 = new 数据类型 【数组长度】；

解析含义：
左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型
左侧中括号，代表我是一个数组
左侧数组名称，给数组取一个名字
右侧的new， 代表创建数组的动作
右侧数据类型，必须和左边的数据类型保持一致
右侧中括号的长度，也就是数组当中，到底可以保存多少个数据，是一个int 数字

静态初始化数组的格式：
数据类型【】 数组名称 = new 数据类型【】{元素1，元素2}

省略格式：
数据类型【】 数组名称 = {元素1， 元素2}

注意事项：
1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2. 静态初始化标准格式可以拆分成为两个步骤
3. 动态初始化也可以拆分成为两个步骤
4. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤

使用建议：
如果不确定数组当中的具体内容，用动态初始化； 否则，已经确定具体内容，用静态初始化。


访问数组元素的格式： 数组名称【索引值】
索引值： 就是一个int数字，代表数组当中元素的编号
【注意】索引值从0开始，一直到“数组的长度-1”为止。


Java的内存需要划分成为5个部分：

1. 栈 （Stack）： 存放的都是方法中的局部变量。方法的运行一定要在栈当中运行
            局部变量： 方法的参数，或者是方法{}内部的变量
            作用域： 一旦超出作用域，立刻从栈内存当中消失。
2. 堆 （Heap）： 凡是new出来的东西，都在堆当中
        堆内存里面的东西都有一个地址值： 16进制
        堆内存里边的数据，都是默认值。规则：
                如果是整数           默认为： 0
                如果是浮点数          默认为： 0.0
                如果是字符           默认为： ‘\u0000’
                如果是布尔           默认为： false
                如果是引用类型        默认为： null
方法区 （Method Area）： 存储。class相关信息，包括方法的信息

本地方法栈 （Natice Method Stack）： 与操作系统相关

寄存器 （pc Register）： 与CPU相关




一个方法可以有0，1，多个参数；但是只能有0或者1个返回值，不能有多个返回值。
如果希望一个方法当中产生了多个结果进行返回，怎么办？
解决方案： 使用一个数组作为返回值类型即可。

任何数据类型都能作为方法的参数类型，或者返回值类型。

数组作为方法的参数，传递进去的其实是数组的地址值。
数组作为方法的返回值，返回的其实也是数组的地址值。


局部变量和成员变量

1.定义的位置不一样【重点】
局部变量： 在方法的内部
成员变量： 在方法的外部，直接写在类当中

2.作用范围不一样【重点】
局部变量： 只有方法当中才可以使用，出了方法就不能再用
成员变量： 整个类全都可以通用。

3.默认值不一样【重点】
局部变量： 没有默认值，如果想要使用，必须手动进行赋值
成员变量： 如果没有赋值，会有默认值，规则和数组一样

4.内存的位置不一样
局部变量： 位于栈内存
成员变量： 位于堆内存

5.生命周期不一样
局部变量： 随着方法进栈而诞生，随着方法出栈而消失
成员变量： 随着对象创建而诞生，随着对象被垃圾回收而消失



面向对象三大特征：封装，继承，多态。

封装性在Java当中的体现：
1.方法就是一种封装
2.关键字private也是一种封装

封装就是将一些细节信息隐藏起来，对于外界不可见。



问题描述： 定义Person的年龄时，无法阻止不合理的数值被设置进来。
解决方案： 使用private关键字将需要保护的成员变量进行修饰。

一旦使用了private进行修饰，那么本类当中仍然可以随意访问。
但是！超出了本类范围之外就不能直接访问了。

间接访问private成员变量，就是定义一对儿Getter/Setter方法

必须叫setXxx或者是getXxx命名规则。
对于Getter来说，不能有参数，返回值类型和成员变量对应。
对于setter来说，不能有返回值，参数类型和成员变量对应。


当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。
如果要访问本类当中的成员变量，需要使用格式：
this.成员变量名需


注意事项：
1. 构造方法的名称必须和所在类名称完全一样，就连大小写也要一样
2. 构造方法不要写返回值类型，连void都不要写
3. 构造方法不能return一个具体的返回值
4. 如果没有编写任何构造方法，那么编译器就会默认赠送一个构造方法，没有参数，方法体什么事情都不做。
public Student（）{}
5. 一旦编写了至少一个构造方法，那么编译器将不再赠送。
6. 构造方法也是可以进行重载的
方法名称相同，参数列表不同。





一个标准的类通常要拥有下面四个组成部分：

1. 所有成员变量都要使用private关键字修饰
2. 为每一个成员变量编写一对儿Getter/Steer方法
3.编写一个无参数的构造方法
4.编写一个全参数的构造方法

这样标准的类也叫做 Java Bean




Scanner类的功能： 可以实现键盘输入数据，到程序当中。

引用类型的一般使用步骤：

1. 导包
import 包路径.类名称；
如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。
只有java。lang包下的内容不需要导包，其他的都需要import语句。

2.创建
类名称 对象名 = new 类名称（）；

3.使用
对象名.成员方法名（）


获取键盘输入的一个int数字： int num = sc.nextInt();
获取键盘输入的一个字符串：String str = sc.next();





创建对象的标准格式：
类名称 对象名 = new 类名称（）；

匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。
new 类名称（）；

注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。
使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。


数据的长度不可以发生改变。
但是ArrayList集合的长度是可以随意改变的。

对于ArrayList来说，有一个尖括号<E>代表泛型。
泛型：也就是装在集合当中的所有元素，全都是统一的水面类型。
注意：泛型只能是引用类型，不能是基本类型。

注意事项：
对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。
如果内容是空，得到的是空的中括号：【】



ArrayList当中的常用方法有：

public boolean add（E e）：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。
备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。
但是对于其他集合来说，add添加动作不一定成功。

public E get（int index）: 从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。

public E remove（int index）：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。

public int size（）：获取集合的尺寸长度，返回值是集合中包含的元素个数。



如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。

基本类型              包装类（引用类型，包装类都位于java.lang包下）
byte                  Byte
short                 Short
int                   Integer            [特殊]
long                  Long
float                 Float
double                Double
char                  Character         [特殊]
boolean               Boolean

从JDK 1.5+开始，支持自动装箱，自动拆箱。

自动装箱： 基本类型 --> 包装类型
自动拆箱： 包装类型 --> 基本类型




java.lang.String类代表字符串。
API当中说：Java程序中的所有字符串字面值（如 “abc”）都作为此类的实例实现。
其实就是说: 程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）

字符串的特点：
1. 字符串的内容用不可变。【重点】
2. 正是因为字符串不可改变，所以字符串是可以共享使用的。
3. 字符串效果上相当于是char【】字符数组，但是底层原理是byte【】字节数组。

创建字符串的常见3+1中方式。
三种构造方法：
public String（）：创建一个空白字符串，不含有任何内容。
public String（char[] array）：根据字符数组的内容，来创建对应的字符串。
public String（byte[] array）：根据字节数组的内容，来创建对应的字符串。
一种直接创建：
String str = “hello”;

注意： 直接写上双引号，就是字符串对象。





字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。

对于基本类型来说， ==是进行数值的比较。
对于引用类型来说， ==是进行【地址值】的比较。


 ==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法：

publi boolean equals（Object obj）：参数可以是任何对象，只有参数是一个字符串并且内容相同才会给true，否则false

注意事项：
1. 任何对象都能用Object进行接收。
2. equals方法具有对称性，也就是a.equals(b)和 b.equals(a)效果是一样的。
3.如果比较双方一个常量一个变量，推荐吧常量字符串写在前面。
推荐： “abc”.equals(str)        不推荐: str.equals("abc")

public boolean equalsIgnoreCase(String str): 忽略大小写，进行内容比较。


String 当中与获取相关的常用方法有：

public int length(): 获取字符串当中含有的字符个数，拿到字符串长度。
public String concat(String str): 将当前字符串的参数字符串拼接成为返回值新的字符串。
public char charAt(int index): 获取指定索引位置的单个字符。（索引从0开始）
public int indexOf（String str）： 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。


字符串的截取方法：

public String substring(int index): 截取从参数位置一直到字符串末尾，返回新字符串。
public String substring (int begin, int end ): 获取从begin开始， 一直到end结束，中间的字符串。
备注：[begin, end) ， 包含左边，不包含右边。


String当中与转换相关的常用方法有：

public char[] toCharArray(): 将当前字符串拆分成为字符数组作为返回值。
public byte[] getBytes(): 获得当前字符串底层的字节数组。
public String replace(CharSepuence oldString, CharSequence newString):
将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。
备注：CharSequence意思就是说可以接受字符串类型。


分割字符串的方法：
public String[] split(String regex): 按照参数的规则，将字符串切分成为若干部分。

注意事项：
split方法的参数其实是一个“正则表达式”，今后学习。
今天要注意：如果按照英文句点“.” 进行切分，必须写“\\.” (两个反斜杠)

如果一个成员变量使用了static关键字，那么这个变量不在属于对象自己，而是属于所在的类。多个对象共享同一份数据。

一旦使用static修饰成员方法，那么这就成为静态方法。静态方法不属于对象，而是属于类的。

如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用。
如果没有stati关键字，那么不需要创建对象，直接就能通过类名称来使用它。

无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。

静态变量：类名称。静态变量
静态方法：类名称，静态方法（）


注意事项：
1. 静态不能直接访问非静态
原因：因为在内存当中是【先】有静态内容，【后】有的非静态内容。
“先人不知道后人，但是后人知道先人。”
2.静态方法当中不能用this。
原因： this代表当前对象，通过谁调用的方法，谁就是当前对象。



java.util.Array是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。

public static String toString（数组）：将参数数组变成字符串（按照默认格式：【元素1， 元素2， 元素3...】）
public static void sort（数组）：按照默认升序（从小到大）对数组的元素进行排序。

备注：
1. 如果是数组，sort默认按照升序从小到大
2. 如果是字符串，sort默认按照字母升序
3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。



Math数学工具常用的操作
1. abs  获取绝对值，有多种重载。
2. ceil 向上取整。
3. floor 向下取整。
4. round 四舍五入

Mat.PI代表近似圆周率常量



面向对象的三大特征：封装性, 继承性， 多态性。继承是多态的前提，如果没有继承，就没有多态。

继承关系当中的特点：
1. 子类可以拥有父类“内容”
2. 子类还可以拥有自己的专有内容

继承主要解决的问题： 共性抽取


在继承关系中， “子类就是一个父类”。 也就是说， 子类可以被当做父类看待。
例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系： is-a。

定义父类的格式：（一个普通的类定义）
public class 父类名称{
        //、、、、
}

定义子类的格式：

public class 子类名称 extends 父类名称{
        //、、、、




在父子类的继承关系当中，如果成员变量重名，则创建子对象时，访问有两种方式。

直接通过子类对象访问成员变量：
    等号左边是谁，就优先用谁，没有则向上找。
间接通过成员方法访问成员变量：
    该方法属于谁，就优先用谁，没有则向上找


在父类的继承关系当中，创建子类对象，访问成员方法的规则：
        创建的对象是谁，就优先用谁，如果没有则向上找。

注意事项：

无论是成员方法还是成员变量，如果没有都是向上找父类， 绝对不会向下找子类。

重写（override）
概念：在继承关系当中，方法的名称一样，参数列表也一样。

重写（override）： 方法的名称一样，参数列表【也一样】  覆盖 覆写
重载（overload）： 方法的名称一样，参数列表【不一样】




方法覆盖重写的注意事项：

1. 必须保证父子类之间方法的名称相同，参数列表也相同。
@override: 写在方法前面，用来检测是不是有效的正确的覆盖重写
这个注释就算不写，也要满足要求，也是正确的方法覆盖重写

2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
小扩展提示： java。long。Object类是所有类的公共最高父类

3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
小扩展提示: public > protected > (default) > private
备注： （default）不是关键字default： 而是什么都不写，留空


接口就是多个类的公共规范
接口就是一种引用数据类型，最重要的内容就是其中的：抽象方法。

如何定义一个接口的格式：
public Interface 接口名称 {
      //接口内容
}

备注： 换成了关键字interface之后，编译生成的字节码文件仍然是： .java --> .class

如果是Java 7 ，那么接口中可以包含的内容有：
1. 常量
2. 抽象方法

如果是Java 8 ，还可以额外包含有：
3. 默认方法
4. 静态方法

如果是Java 9，还可以额外包含有：
5.私有方法

接口使用步骤：

1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。
格式：
public class 实现类名称 implements 接口名称  {
        //.....
 }
 2. 接口的实现必须覆盖重写（实现）接口中所有的抽象方法。
 实现： 去掉abstract关键字，加上方法体大括号。
 3. 创建实现类的对象，进行使用。

注意事项：
如果实现类并没有覆盖重写接口所在的抽象方法，那么这个实现类自己就必须是抽象类




问题描述：
我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码问题。
但是这个共有方法不应该让实现类使用，应该是私有化的。

解决方案：
从Java 9开始，接口当中允许定义私有方法。
1. 普通私有方法，解决多个默认方法之间重复代码问题
格式：
private 返回值类型 方法名称（参数列表）{
            方法体
}

2. 静态私有方法，解决多个静态方法之间重复代码问题
格式
private static 返回值类型方法名称（参数列表）{
        方法体
}




接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】。
格式：
public static final 数据类型 常量名称 = 数据值；
备注：
一旦使用final关键字进行修饰， 说明不可改变。

注意事项：
1. 接口当中的常量，可以省略public static final， 注意：不写也照常是这样。
2. 接口当中的常量，必须去进行赋值，不能不赋值。
3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）




接口内容小结：

1. 成员变量其实就是常量， 格式：
public static final 数据类型 常量名称 = 数据值；
注意：
    常量必须进行赋值，而且一旦赋值不能改变。
    常量名称完全大写，用下划线进行分隔。

2. 接口中最重要的就是抽象方法，格式：
public abstract 返回值类型 方法名称（参数列表）；
注意： 实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。

3. 从Java 8 开始，接口里允许定义默认方法，格式：
public default 返回值类型 方法名称（参数列表）{ 方法体    }
注意：默认方法也可以被覆盖重写

4.接口里允许定义静态方法， 格式:
public static 返回值类型 方法名称（参数列表）{方法体}
注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法

5.从Java 9开始，接口里允许定义私有方法，格式：
普通私有方法：private 返回值类型 方法名称（参数列表）{方法体 }
静态私有方法：private static 返回值类型 方法名称（参数列表） {方法体}
注意： private的方法只有自己才能调用，不能被实现类或别人使用。


代码当中体现多态性，其实就是一句话：父类引用指向子类对象。

格式：
父类名称 对象名 = new 子类名称（）;
或者：
接口名称 对象名 = new 实现类名称（）;

1. 类与类之间是单继承的，直接父类只有一个。
2. 类与接口之间是多实现的，一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

注意事项：
1. 多个父接口当中的抽象方法如果重复，没关系。
2. 多个父类接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写 【而且带着default关键字】

在多态的代码中，成员方法的访问规则是：

    看new的是谁，就优先用谁，没有则向上找。

口诀： 编译看左边，运行看右边。

对比一下：
成员变量：编译看左边，运行还看左边。
成员方法：编译看左边，运行看右边。




如果不用多态，只用子类，那么写法是：
Teacher one = new Teaher（）;
one.work();
Assistant two = new Assistant;
two.work();


如果使用多态的写法，对比一下：

Employee one = new Teacher();
one.work();
Employee two = new Assistant();
two.work();

好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会改变。

就是将父类放在左边，子类放在右边，当有同一个父类的时候，左边的父类一样。




对象的向上转型，其实就是多态写法：
格式：父类名称 对象名 = new 子类名称();               Animal animal = new Cat();
含义：右侧创建一个子类对象，吧她当做父类来看待使用。      创建了一只猫，当做动物看待，没问题。
注意事项：向上转型一定是安全的，从小范围转向了大范围，从小范围的猫，向上转型成为更大范围的动物。


2. 对象的向下转型，其实就是一个【还原】的动作。
格式： 子类名称 对象名 = （子类名称）父类对象;
含义：将父类对象，【还原】成为本来的子类对象；

Animal animal = new Cat();
Cat cat = (Cat)animal;

注意事项:
a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。
b.如果对象创建的时候本来不是猫，现在非要 向下转型成为猫，就会报错。





当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。

注意事项：
对于类，方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。


Java中有四种权限修饰符：
                            public  >   protected   >   (default)   >   private
同一个类（我自己）              YES          YES             YES             YES
同一个包（我邻居）              YES          YES             YES             NO
不同包子类（我儿子）            YES          YES             NO              NO
不同包非子类（陌生人）          YES          NO              NO              NO

当final关键字用来修饰一个类的时候，格式：
public final class 类名称 {
       //...
}

含义：当前这个类不能有任何子类。
注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写



如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
例如：身体和心脏的关系。

分类：
1. 成员内部类
2. 局部内部类（包含匿名内部类）

成员内部类的定义格式：
修饰符 class 外部类名称{
    修饰符 class 外部类名称{

    }

}

注意：内用外，随意访问；外用内，需要内部类对象。

如何使用成员内部类？有两种方法：
1. 间接方式：在外部类的方法当中，使用内部类：然后main只是调用外部类的方法。
2.直接方法：公式
外部类名称。内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）；



如果一个类是定义在一个方法内部，那么这就是一个局部内部类。
“局部 ”： 只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

定义格式：
修饰符 class 外部类名称{
    修饰符 返回值类型 外部类方法名称（参数列表） {
        class 局部内部类方法 {

        }
    }
}

小节一下类的权限修饰符：
public > protected > (default) > private
定义一个类的时候，权限修饰符的规则：
1. 外部类： public / (default)
2. 成员内部类： public / protected / (default) / private
3. 局部变量： 什么都不写

 */


